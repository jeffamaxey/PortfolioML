''' Setting up of the portfolios obtained by appling long top k and short bottom k
srategy on the results of the ANN models trained. '''
import argparse
import logging
import os
import random

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from portfolioML.makedir import go_up, smart_makedir
from scipy import stats


def get_trading_values(df_price, algorithm, model_name, num_periods, len_period=1308, len_train=981, len_test=327):
    '''
    Add Dates column to the dataframes generated by the model training, due to
    fact that it doesn't track them and they are necessary for appling the trading
    strategy.

    Parameters
    ----------
    df_price : pandas datafrme
        Pandas dataframe of prices.
    algorithm : str
        LSTM, DNN or CNN.
    model_name : str
        Name of the particular selected model trained. Check the name of folders in predictions/<algorithm>.
    num_periods : int
        Number of period over which forecast returns have to be calculated.
    len_period : int, optional
        Lenght of each study period. The default is 1308.
    len_train : int, optional
        Lenght of the training set. The default is 981.
    len_test : int, optional
        Lenght of the trading set. The default is 327.

    Returns
    -------
    None.

    '''
    len_total_leave = len(df_price) - len_period

    # Divide in periods the price dataframe
    periods_price = [(df_price[i:len_period + i])
                     for i in range(0, len_total_leave + 1, len_test)]

    # Select only the test sets
    tests = [periods_price[i][len_train:] for i in range(len(periods_price))]

    # Select, then, only days in test sets of which forecasts are actually made
    trading_values = [tests[i][240:] for i in range(len(tests))]

    smart_makedir(f'predictions_for_portfolio/{algorithm}/{model_name}')
    path1 = os.getcwd() + \
        f'/predictions_for_portfolio/{algorithm}/{model_name}'

    # Insert the 'Date' column in the forecasts made by lstm.py
    for i in range(num_periods):
        ith_predictions = pd.read_csv(
            f"predictions/{algorithm}/{model_name}/{model_name}_Predictions_{i}th_Period.csv")
        ith_predictions.insert(0, 'Date', trading_values[i]['Date'].values)

        # Save the csv file
        ith_predictions.to_csv(
            f"{path1}/Trading_days_period{i}.csv", index=False)
    logging.info("Successfully tracked forecasts dates")


def portfolio_creation(algorithm, model_name, num_periods, k=10):
    '''
    This function creates a list composed by pandas dataframe each of which contains
    the top k and bottom k forecasts made by the algorithm in the whole trading
    periods.

    Parameters
    ----------
    algorithm : str
        LSTM, DNN or CNN.
    model_name : str
        Name of the particular selected model trained. Check the name of folders in predictions/<algorithm>.
    num_periods : int
        Number of period over which forecast returns have to be calculated.
    k : int, optional
        Number of top and flop forecasts that will be considered. The default is 10.

    Returns
    -------
    portfolio : list
        List of pandas dataframes.

    '''

    get_trading_values(df_price, algorithm, model_name, num_periods)
    path = f'{os.getcwd()}/predictions_for_portfolio/{algorithm}/{model_name}'
    portfolio = []
    for j in range(num_periods):
        trading_days = pd.read_csv(
            f"{path}/Trading_days_period{j}.csv")
        portfolio_tmp = []
        for i in range(trading_days.shape[0]):
            df_portfolio = pd.DataFrame()

            # Select the ith day
            day = trading_days['Date'][i]

            # Select and order the values of that day
            values = trading_days.iloc[i][1:]
            values = values.sort_values()

            # Select top e bottom k values and corresponding companies
            top_k_val, top_k_comp = values[:k], values[:k].index
            bottom_k_val, bottom_k_comp = values[-k:], values[-k:].index
            values_traded = list(top_k_val.values) + list(bottom_k_val.values)
            companies_traded = list(top_k_comp) + list(bottom_k_comp)

            # Put all them in a dataframe
            df_portfolio[day] = values_traded
            df_portfolio['Company'] = companies_traded
            portfolio_tmp.append(df_portfolio)
        portfolio.append(portfolio_tmp)
    return portfolio


def forecast_returns(df_price, num_periods, k=10, money=1000., monkey=False):
    '''
    The following is aimed to calculate the daily returns. We set a long position for the
    top k companies at each day and a short position for the bottom k ones. So, we
    calculate the returns using prices ad t ad t+1 for the formers and t-1 ad t for the
    latters.

    Parameters
    ----------
    df_price : pandas datafrme
        Pandas dataframe of prices.
    num_periods : int
        Number of period over which forecast returns have to be calculated.
    k : int,  optional
        Number of top and flop forecasts that will be considered. The default is 10.
    money : float, optional
        How much you want to invest.
    monkey : bool, optional
        For the randomness test. The default is False.

    Returns
    -------
    returns : numpy array
        Numpy array of all returns for all periods.
    accumulative_returns : numpy array
        Accumulative returns obtained by investing 1USD each day.
    '''
    global num_periods_g
    global k_g
    global money_g

    num_periods_g = num_periods
    k_g = k
    money_g = money

    returns = []
    for period in range(num_periods):
        for i in range(len(portfolio[0])):

            # Select one trading day
            trading_day = portfolio[period][i].columns[0]
            if monkey:
                rand = random.sample(range(1, len(df_price.columns)), 2 * k)
                companies = df_price.columns[rand]
            else:
                # List all companies in that day
                companies = portfolio[period][i].Company.tolist()

                # Select the corresponding index in df_price
            index = df_price.Date[df_price.Date == trading_day].index.tolist()
            index = index[0]

            # Determine the returns for long and short positions
            for i, comp in enumerate(companies):
                if i <= (k - 1):
                    returns.append(
                        df_price[comp][index] / df_price[comp][index + 1] - 1)
                else:
                    returns.append(
                        df_price[comp][index + 1] / df_price[comp][index] - 1)
    returns = np.array(returns)  # 870*2*k
    returns_rs = np.reshape(returns, (int(len(returns) / (2 * k)), (2 * k)))

    # Accumulative returns
    accumulative_returns = []
    for day_returns in returns_rs:
        money = money + ((money * 0.1 / (2 * k)) * day_returns).sum()
        accumulative_returns.append(money)
    accumulative_returns = np.array(accumulative_returns)

    # Mean daily returns
    returns_dr = np.reshape(
        returns, (int(returns.shape[0] / (2 * k)), (2 * k)))
    mean_daily_returns = [day_ret.mean() for day_ret in returns_dr]

    if monkey:
        logging.info('\U0001F435 Average daily returns %2f', returns.mean())
        logging.info('\U0001F435 Standard deviation %2f', returns.std())
    else:
        logging.info('Average model daily returns %2f', returns.mean())
        logging.info('Standard model deviation %2f', returns.std())

    return returns, accumulative_returns


def monkey_trading(df_price, monkeys_num, num_periods, k=10, money=1.):
    """
    Randomness test. We select at random 2*k companies and we use on them the
    same strategy of long k and short k.
    Returns and accumulative returns made by monkeys' trading (i.e. random trading).

    Parameters
    ----------
    df_price : pandas datafrme
        Pandas dataframe of prices.
    monkey_num : int
        How much monkey do you want?
    num_periods : int
        Number of period over which forecast returns have to be calculated.
    k : int,  optional
        Number of top and flop forecasts that will be considered. The default is 10.
    money : float, optional
        How much you want to invest.

    Returns
    ---------
    mean_daily_ret : numpy array
        Mean daily return for each monkey
    accumulative_ret_mon : numpy array
        Accumulative return for each monkey (1USD of invest each day)

    """

    # Monkey statistic
    returns_dr = []
    accumulative_dr = []
    for _ in range(0, monkeys_num):
        returns, acc_returns_m = forecast_returns(
            df_price, num_periods=num_periods, k=k, money=money, monkey=True)
        returns = np.reshape(
            returns, (int(returns.shape[0] / (2 * k_g)), (2 * k_g)))
        returns_dr.append(returns)
        accumulative_dr.append(np.array(acc_returns_m))

    returns_dr = np.array(returns_dr)  # (num_monkey, 870, 2*k)
    # all monkeys returns for each day
    returns_dr = np.reshape(
        returns_dr, (returns_dr.shape[0] * returns_dr.shape[1], returns_dr.shape[2]))
    # one day mean for each day for each monkey
    mean_daily_ret = np.array([day_ret.mean() for day_ret in returns_dr])

    accumulative_dr = np.array(accumulative_dr)
    acc_monkey_mean = np.mean(accumulative_dr, axis=0)
    acc_monkey_std = np.std(accumulative_dr, axis=0)
    monkey_std_upper = (acc_monkey_mean + acc_monkey_std)
    monkey_std_lower = (acc_monkey_mean - acc_monkey_std)

    accumulative_ret_mon = [acc_monkey_mean,
                            monkey_std_upper, monkey_std_lower]

    return mean_daily_ret, accumulative_ret_mon


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description='''Creation of portfolios based on selected model predictions
         and plot basic statistical. See the second note at https://portfolioml.readthedocs.io/en/latest/source/guidelines.html
        for more information.''')
    requiredNamed = parser.add_argument_group('Required named arguments')
    requiredNamed.add_argument(
        '--algorithm', '-a', type=str, action='append', help='CNN, LSTM , DNN and/or RAF')
    requiredNamed.add_argument('--model_name', '-m', type=str,
                               action='append', help='Select the particular model trained')
    parser.add_argument("--num_periods", '-p', type=int,
                        help="Number of period over which returns have to be calculated ")
    parser.add_argument("--money", '-€', type=int, default=1000,
                        help="How much you want to invest")
    parser.add_argument("--top_bottom", '-tp', type=int, default=10,
                        help="Number of top (long pos) and bottom (short pos)")
    parser.add_argument("-log", "--log", default="info",
                        help=("Provide logging level. Example --log debug', default='info"))
    parser.add_argument("--monkeys_num", type=int, default=500,
                        help="How many monkeys do you want?")
    args = parser.parse_args()

    levels = {'critical': logging.CRITICAL,
              'error': logging.ERROR,
              'warning': logging.WARNING,
              'info': logging.INFO,
              'debug': logging.DEBUG}

    logging.basicConfig(level=levels[args.log])

    df_price = pd.read_csv(go_up(1) + "/data/PriceData.csv")
    df_price = df_price.dropna(axis=1)

    for i, (alg, mod) in enumerate(zip(args.algorithm, args.model_name), start=1):
        logging.info(f"---------- Model {mod} ----------")
        path = f'{os.getcwd()}/predictions_for_portfolio/{alg}/{mod}'

        # Portfolios Generator
        portfolio = portfolio_creation(alg, mod, args.num_periods)

        # List of trading day:
        flat_list = [item for sublist in portfolio for item in sublist]
        trading_days = [item.columns[0] for item in flat_list]
        x_label_position = np.arange(0, len(trading_days), 50)
        x_label_day = [trading_days[i] for i in x_label_position]

        # Accumulate Returns
        plt.figure("Accumulative Returns", figsize=[13., 10.])
        if i == 1:
            monkey_ret, accumulative_monkey = monkey_trading(df_price, monkeys_num=args.monkeys_num,
                                                             num_periods=args.num_periods, money=args.money, k=args.top_bottom)
            plt.plot(accumulative_monkey[0], color='crimson', label='Monkeys')
            plt.fill_between(list(range(0, len(accumulative_monkey[0]))), accumulative_monkey[1], accumulative_monkey[2],
                             color='crimson', alpha=0.2, label=r'$\pm$ 1 std. dev.')

        returns_model, acc_returns_model = forecast_returns(df_price, num_periods=args.num_periods,
                                                            money=args.money, k=args.top_bottom, monkey=False)

        plt.plot(acc_returns_model, label=f'{mod}')
        plt.title("Accumulative Returns over Trading Days")
        plt.xticks(x_label_position, x_label_day, rotation=60)
        plt.xlabel("Trading days")
        plt.ylabel("Accumulative Returns")
        plt.grid(True)
        plt.legend()
        plt.savefig(f"Accumulative returns {args.model_name}")

        # Statistic
        returns_model = np.reshape(returns_model, (int(
            returns_model.shape[0] / (2 * args.top_bottom)), (2 * args.top_bottom)))
        mean_return_mod = np.array([day_ret.mean()
                                   for day_ret in returns_model])
        t_stat, p_val = stats.ttest_ind(
            monkey_ret, mean_return_mod, equal_var=False)

        fig, ax1 = plt.subplots(figsize=[8.0, 6.0])
        ax1.hist(monkey_ret, bins=150, color='crimson',
                 label=f'Monkey return: {monkey_ret.mean():.5f} $\pm${monkey_ret.std():.5f}', alpha=0.9)
        ax2 = ax1.twinx()
        ax2.hist(mean_return_mod, bins=70, color='green',
                 label=f'{mod} Return: {mean_return_mod.mean():.5f} $\pm${mean_return_mod.std():.5f}', alpha=0.5)
        plt.title(
            f'{mod} significant statistic w.r.t {args.monkeys_num} monkeys')
        ax1.plot([], color='white', label=f'p-value: {p_val}')
        ax1.set(xlabel='Average daily return')
        ax1.set(ylabel='Monkeys')
        ax2.set(ylabel='Model')
        fig.legend(bbox_to_anchor=(1.0, 1.0), bbox_transform=ax1.transAxes)
        fig.savefig(f"Statistics model: {mod}")
    plt.show()
